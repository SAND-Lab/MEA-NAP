
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Loading data generated by the Multi Channel DataManager</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-02-06"><meta name="DC.source" content="helpDataManager.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Loading data generated by the Multi Channel DataManager</h1><!--introduction--><p>As an example, lets load a data set with at least 1 analog stream:</p><pre class="language-matlab">data = McsHDF5.McsData(<span class="string">'SOME_DATA_FILE.h5'</span>);
</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#4">Units</a></li><li><a href="#6">Data types</a></li><li><a href="#10">Loading segments of streams</a></li><li><a href="#14">Plotting the data</a></li><li><a href="#20">Frame streams</a></li><li><a href="#24">Plotting frame data</a></li></ul></div><p>Up to this point, only the metadata has been read from the file. The actual data within the stream will be loaded as soon as you try to access the stream, for example in a plot function. The recorded data is organized as follows within the data structure:</p><div><ul><li>Top-level: General information and a cell array of McsRecording objects:</li></ul></div><pre class="language-matlab">data
</pre><div><ul><li>Each recording is stored in its individual cell:</li></ul></div><pre class="language-matlab">data.Recording{1}
</pre><div><ul><li>Each recording cell contains cell arrays of zero or more analog-, frame-, segment-, timestamp- and event streams. The only exception is the frame stream which has additional sub-structures, the FrameDataEntities.</li></ul></div><pre class="language-matlab">data.Recording{1}.AnalogStream{1}
</pre><h2 id="4">Units</h2><p>For each stream, the associated data is stored in the field ChannelData (AnalogStream), SegmentData (SegmentStream with spike cutouts), AverageDataMean (SegmentStream with averages) FrameData (FrameDataEntity of FrameStreams), Events (EventStream) of Timestamps (TimeStampStream). Accessing one of these will load the data from the file. Per default, these values have already been converted during loading from ADC units to more useful units such as Volts. The actual unit it is represented in can be found for each stream in the fields Unit and Exponent (values 'V' and -9, respectively, mean that the data is stored in <img src="helpDataManager_eq09220389044114281081.png" alt="$$ 10^{-9} $$"> V) of its Info structure:</p><pre class="language-matlab">data.Recording{1}.AnalogStream{1}.Info.Unit{1}
data.Recording{1}.AnalogStream{1}.Info.Exponent(1)
</pre><p>The time stamp associated with each sample is stored in the field {Channel,Frame,Segment}DataTimeStamps in microseconds. Similarly, the time stamps of events in the EventStream or time stamps in the TimeStampStream are stored in microseconds as well. For segment streams with averages, the field AverageDataTimeStamps denotes the time range used to compute the averages.</p><h2 id="6">Data types</h2><p>For some applications, it might be necessary to change the data type of the data and the time stamps, for example because of memory constraints. The default data type for the {Channel,Frame,Segment,Average}Data is 'double'. By specifying the data type during the loading of the file, you can halve the memory requirements by using 'single' instead.</p><pre class="language-matlab">cfg = [];
cfg.dataType = <span class="string">'single'</span>;
data = McsHDF5.McsData(<span class="string">'SOME_DATA_FILE.h5'</span>,cfg);
</pre><p>This may, however, lead to very minor inaccuracies and one can encounter problems with Matlab functions that except the data to be in 'double' format.</p><p>Another possibility to potentially save even more memory is to specify</p><pre class="language-matlab">cfg = [];
cfg.dataType = <span class="string">'raw'</span>;
data = McsHDF5.McsData(<span class="string">'SOME_DATA_FILE.h5'</span>,cfg);
</pre><p>With the 'raw' option , the data is stored in its original format internally in ADC units, so no conversion into meaningful units is performed. Because the data type of the original data can be 16 Bit integer (int16), this can reduce the memory requirements to 1/4th compared to the default 'double' format.</p><p>One can convert data loaded with the 'raw' option to meaningful units either manually (in this example for the first channel of an analog stream):</p><pre class="language-matlab">converted_data = (data.Recording{1}.AnalogStream{1}.ChannelData(1,:) - <span class="keyword">...</span>
                    data.Recording{1}.AnalogStream{1}.Info.ADZero(1)) * <span class="keyword">...</span>
                    data.Recording{1}.AnalogStream{1}.Info.ConversionFactor(1);
</pre><p>or by using the getConvertedData function which converts and returns the full data array:</p><pre class="language-matlab">cfg = [];
cfg.dataType = <span class="string">'double'</span>;
converted_data = data.Recording{1}.AnalogStream{1}.getConvertedData(cfg);
</pre><h2 id="10">Loading segments of streams</h2><p>For some applications, it can be beneficial to load only segments of a stream instead of the full data. For example, due to the file size and the amount of available memory, loading a full AnalogStream might not be possible. Or, one might only be interested in a portion of the data.</p><p>This can be achieved by first loading the metadata:</p><pre class="language-matlab">data = McsHDF5.McsData(<span class="string">'SOME_DATA_FILE.h5'</span>);
</pre><p>and then loading only a subset of channels and/or a specified time window. This results in a new McsAnalogStream object, which can, for example, still be accessed as usual by the plot function:</p><pre class="language-matlab">cfg = [];
cfg.channel = [5 15]; <span class="comment">% channel index 5 to 15</span>
cfg.window = [42 1093]; <span class="comment">% time range 42 s to 1093 s</span>
partialData = data.Recording{1}.AnalogStream{1}.readPartialChannelData(cfg);
plot(partialData,[]); <span class="comment">% plot the analog stream segment</span>
</pre><p>Similar functions that allow loading parts of the full data set are available for all stream types:</p><pre class="language-matlab">data.Recording{1}.AnalogStream{1}.readPartialChannelData(cfg)
data.Recording{1}.EventStream{1}.readPartialEventData(cfg)
data.Recording{1}.FrameStream{1}.FrameDataEntity{1}.readPartialFrameData(cfg)
data.Recording{1}.SegmentStream{1}.readPartialSegmentData(cfg)
data.Recording{1}.TimeStampStream{1}.readPartialTimeStampData(cfg)
</pre><h2 id="14">Plotting the data</h2><p>Each stream has simple plot functions to allow a quick check whether the data is all right:</p><pre class="language-matlab">plot(data.Recording{1}.AnalogStream{1},[])
plot(data.Recording{1}.EventStream{1},[])
plot(data.Recording{1}.SegmentStream{1},[])
plot(data.Recording{1}.TimeStampStream{1},[])
</pre><p>If for example the event stream and the segment streams have not been accessed before, their data is loaded during the execution of the respective plot function.</p><p>Plot functions can also be executed at the recording or top level in order to get an overview over all streams in the recording, or even all streams in the data:</p><pre class="language-matlab">plot(data.Recording{1},[]);
plot(data,[]);
</pre><p>If the second parameter of the plot function is empty, the default parameters are used for plotting. Otherwise, one can specify configuration structures for more fine-grained plotting. For example, the following commands will plot channels 1 and 2 of the second analog stream:</p><pre class="language-matlab">cfg = [];
cfg.channel = [1 2];
plot(data.Recording{1}.AnalogStream{2},cfg);
</pre><p>Each plot function has its own set of options, so you need to check the individual help functions for the specifics:</p><pre class="language-matlab">help <span class="string">McsHDF5.McsEventStream.plot</span>
</pre><p>You can specify these configuration options also in higher level plot functions to achieve the same thing:</p><pre class="language-matlab">cfg = [];
cfg.analog{2}.channel = [1 2];
plot(data.Recording{1},cfg);
</pre><pre class="language-matlab">cfg = [];
cfg.conf.analog{2}.channel = [1 2];
plot(data,cfg);
</pre><p>You can also specify additional options in the plot function. These are forwarded to the underlying MATLAB plotting functions. The following command produces a time series plot of the first analog stream with thick dashed red lines:</p><pre class="language-matlab">plot(data.Recording{1}.AnalogStream{1},cfg,<span class="string">'--r'</span>,<span class="string">'LineWidth'</span>,5);
</pre><h2 id="20">Frame streams</h2><p>Frame streams have to be treated in more detail, because they can lead to potentially very large data sets. They comprise samples from a 2D array of recording channels for a total of possibly several thousand channels. Because of this, it can be problematic to store the full data cube (channels_x <img src="helpDataManager_eq06716003005155465776.png" alt="$$ \times $$"> channels_y <img src="helpDataManager_eq06716003005155465776.png" alt="$$ \times $$"> time) in memory. If you know which parts of the data you are interested in, you can also load just a small 'cuboid' (a 'hyperslab' in HDF5 terminology) to memory:</p><p>First, load just the metadata:</p><pre class="language-matlab">frameData = McsHDF5.McsData(<span class="string">'FILE_WITH_FRAME_DATA.h5'</span>);
</pre><p>If we would execute one of the following commands, the whole frame would be loaded, which we want to avoid to save memory.</p><pre class="language-matlab">size(frameData.Recording{1}.FrameStream{1}.FrameDataEntity{1}.FrameData)
plot(frameData.Recording{1}.FrameStream{1}.FrameDataEntity{1},[])
plot(frameData,[])
</pre><p>To avoid memory problems, you can load a region of interest as follows:</p><pre class="language-matlab">cfg = [];
cfg.window = [0 0.5]; <span class="comment">% 0 to 0.5 s</span>
cfg.channel_x = [10 30]; <span class="comment">% channel "rows" 10 to 30</span>
cfg.channel_y = []; <span class="comment">% all channel "columns"</span>
partialData = frameData.Recording{1}.FrameStream{1}.FrameDataEntity{1}.readPartialFrame(cfg);
</pre><p>where 'window', 'channel_x' and 'channel_y' are 2x1 vectors of [start end] indices. For 'window', these are given in seconds with respect to the FrameDataTimeStamps, for the channels these are channel indices. If any of these is an empty array, the whole dimension is used. partialFrame contains only the specified subregion of the frame.</p><h2 id="24">Plotting frame data</h2><p>Due to the high dimensionality, finding useful plotting functions for frame data with several thousands of channels can be tricky. Three options are provided here:</p><p>3D-plot of a single slice through the frame, i.e. the amplitudes of all channels for a single time point:</p><pre class="language-matlab">cfg = [];
cfg.window = 0.1; <span class="comment">% 100 ms</span>
plot(partialData,cfg);
</pre><p>A 2D-array of line plots, each depicting the signal at each channel in a specified time range:</p><pre class="language-matlab">cfg = [];
cfg.window = [0.1 0.2]; <span class="comment">% 100 ms to 200 ms</span>
plot(partialData,cfg);
</pre><p>A "movie" of the 3D-plots:</p><pre class="language-matlab">clf
cfg = [];
cfg.start = 0.1;
cfg.end = 0.2;
frameMovie(partialData,cfg);
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Loading data generated by the Multi Channel DataManager
% As an example, lets load a data set with at least 1 analog stream:
%
%   data = McsHDF5.McsData('SOME_DATA_FILE.h5');

%%
% Up to this point, only the metadata has been read from the file. The
% actual data within the stream will be loaded as soon as you try to access
% the stream, for example in a plot function. The recorded data is
% organized as follows within the data structure:
%
% 
% * Top-level: General information and a cell array of McsRecording
% objects:
%
%   data

%%
% * Each recording is stored in its individual cell:
%
%   data.Recording{1}

%%
% * Each recording cell contains cell arrays of zero or more analog-,
% frame-, segment-, timestamp- and event streams. The only exception is the
% frame stream which has additional sub-structures, the FrameDataEntities.
%
%   data.Recording{1}.AnalogStream{1}

%% Units
% For each stream, the associated data is stored in the field ChannelData
% (AnalogStream), SegmentData (SegmentStream with spike cutouts),
% AverageDataMean (SegmentStream with averages) FrameData
% (FrameDataEntity of FrameStreams), Events (EventStream) of Timestamps
% (TimeStampStream). Accessing one of these will load the data from the
% file. Per default, these values have already been converted during
% loading from ADC units to more useful units such as Volts. The actual
% unit it is represented in can be found for each stream in the fields Unit
% and Exponent (values 'V' and -9, respectively, mean that the data is
% stored in $$ 10^{-9} $$ V) of its Info structure:
%
%   data.Recording{1}.AnalogStream{1}.Info.Unit{1}
%   data.Recording{1}.AnalogStream{1}.Info.Exponent(1)

%%
% The time stamp associated with each sample is stored in the field
% {Channel,Frame,Segment}DataTimeStamps in microseconds. Similarly, the
% time stamps of events in the EventStream or time stamps in the
% TimeStampStream are stored in microseconds as well. For segment streams
% with averages, the field AverageDataTimeStamps denotes the time range
% used to compute the averages.

%% Data types
% For some applications, it might be necessary to change the data type of
% the data and the time stamps, for example because of memory constraints.
% The default data type for the {Channel,Frame,Segment,Average}Data
% is 'double'. By specifying the data type during the loading of the file,
% you can halve the memory requirements by using 'single' instead.
%
%   cfg = [];
%   cfg.dataType = 'single';
%   data = McsHDF5.McsData('SOME_DATA_FILE.h5',cfg);
%
% This may, however, lead to very minor inaccuracies and one can encounter
% problems with Matlab functions that except the data to be in 'double'
% format.

%%
% Another possibility to potentially save even more memory is to specify 
%
%   cfg = [];
%   cfg.dataType = 'raw';
%   data = McsHDF5.McsData('SOME_DATA_FILE.h5',cfg);
%
% With the 'raw' option , the data is stored in its original format
% internally in ADC units, so no conversion into meaningful units is
% performed. Because the data type of the original data can be 16 Bit
% integer (int16), this can reduce the memory requirements to 1/4th
% compared to the default 'double' format.

%%
% One can convert data loaded with the 'raw' option to meaningful units
% either manually (in this example for the first channel of an analog stream):
%
%   converted_data = (data.Recording{1}.AnalogStream{1}.ChannelData(1,:) - ...
%                       data.Recording{1}.AnalogStream{1}.Info.ADZero(1)) * ...
%                       data.Recording{1}.AnalogStream{1}.Info.ConversionFactor(1);

%%
% or by using the getConvertedData function which converts and returns the
% full data array:
%
%   cfg = [];
%   cfg.dataType = 'double';
%   converted_data = data.Recording{1}.AnalogStream{1}.getConvertedData(cfg);

%% Loading segments of streams
% For some applications, it can be beneficial to load only segments of a
% stream instead of the full data. For example, due to the file size and
% the amount of available memory, loading a full AnalogStream might not be
% possible. Or, one might only be interested in a portion of the data.

%%
% This can be achieved by first loading the metadata:
%
%   data = McsHDF5.McsData('SOME_DATA_FILE.h5');

%%
% and then loading only a subset of channels and/or a specified time
% window. This results in a new McsAnalogStream object, which can, for
% example, still be accessed as usual by the plot function:
%
%   cfg = [];
%   cfg.channel = [5 15]; % channel index 5 to 15
%   cfg.window = [42 1093]; % time range 42 s to 1093 s
%   partialData = data.Recording{1}.AnalogStream{1}.readPartialChannelData(cfg);
%   plot(partialData,[]); % plot the analog stream segment

%%
% Similar functions that allow loading parts of the full data set are
% available for all stream types: 
%
%   data.Recording{1}.AnalogStream{1}.readPartialChannelData(cfg)
%   data.Recording{1}.EventStream{1}.readPartialEventData(cfg)
%   data.Recording{1}.FrameStream{1}.FrameDataEntity{1}.readPartialFrameData(cfg)
%   data.Recording{1}.SegmentStream{1}.readPartialSegmentData(cfg)
%   data.Recording{1}.TimeStampStream{1}.readPartialTimeStampData(cfg)

%% Plotting the data
% Each stream has simple plot functions to allow a quick check whether the
% data is all right:
%
%   plot(data.Recording{1}.AnalogStream{1},[])
%   plot(data.Recording{1}.EventStream{1},[])
%   plot(data.Recording{1}.SegmentStream{1},[])
%   plot(data.Recording{1}.TimeStampStream{1},[])

%%
% If for example the event stream and the segment streams have not been
% accessed before, their data is loaded during the execution of the
% respective plot function.
%
% Plot functions can also be executed at the recording or top level in
% order to get an overview over all streams in the recording, or even all
% streams in the data:
%
%   plot(data.Recording{1},[]);
%   plot(data,[]);

%%
% If the second parameter of the plot function is empty, the default
% parameters are used for plotting. Otherwise, one can specify
% configuration structures for more fine-grained plotting. For example, the
% following commands will plot channels 1 and 2 of the second analog
% stream:
%
%   cfg = [];
%   cfg.channel = [1 2];
%   plot(data.Recording{1}.AnalogStream{2},cfg);

%%
% Each plot function has its own set of options, so you need to check the
% individual help functions for the specifics:
%
%   help McsHDF5.McsEventStream.plot

%%
% You can specify these configuration options also in higher level plot
% functions to achieve the same thing:
%
%   cfg = [];
%   cfg.analog{2}.channel = [1 2];
%   plot(data.Recording{1},cfg);
%
%   cfg = [];
%   cfg.conf.analog{2}.channel = [1 2];
%   plot(data,cfg);

%%
% You can also specify additional options in the plot function. These are
% forwarded to the underlying MATLAB plotting functions. The following
% command produces a time series plot of the first analog stream with thick
% dashed red lines:
%
%   plot(data.Recording{1}.AnalogStream{1},cfg,'REPLACE_WITH_DASH_DASHr','LineWidth',5);

%% Frame streams
% Frame streams have to be treated in more detail, because they can lead to
% potentially very large data sets. They comprise samples from a 2D array
% of recording channels for a total of possibly several thousand channels.
% Because of this, it can be problematic to store the full data cube
% (channels_x $$ \times $$ channels_y $$ \times $$ time) in memory.
% If you know which parts of the data you are interested in, you can also
% load just a small 'cuboid' (a 'hyperslab' in HDF5 terminology) to memory:
%
% First, load just the metadata:
%
%   frameData = McsHDF5.McsData('FILE_WITH_FRAME_DATA.h5');

%%
% If we would execute one of the following commands, the whole frame would
% be loaded, which we want to avoid to save memory.
%
%   size(frameData.Recording{1}.FrameStream{1}.FrameDataEntity{1}.FrameData)
%   plot(frameData.Recording{1}.FrameStream{1}.FrameDataEntity{1},[])
%   plot(frameData,[]) 

%%
% To avoid memory problems, you can load a region of interest as follows:
%
%   cfg = [];
%   cfg.window = [0 0.5]; % 0 to 0.5 s
%   cfg.channel_x = [10 30]; % channel "rows" 10 to 30
%   cfg.channel_y = []; % all channel "columns"
%   partialData = frameData.Recording{1}.FrameStream{1}.FrameDataEntity{1}.readPartialFrame(cfg);

%%
% where 'window', 'channel_x' and 'channel_y' are 2x1 vectors of [start end]
% indices. For 'window', these are given in seconds with respect to the
% FrameDataTimeStamps, for the channels these are channel indices. If any
% of these is an empty array, the whole dimension is used. partialFrame
% contains only the specified subregion of the frame.

%% Plotting frame data
% Due to the high dimensionality, finding useful plotting functions for
% frame data with several thousands of channels can be tricky. Three options
% are provided here:

%%
% 3D-plot of a single slice through the frame, i.e. the amplitudes of all
% channels for a single time point:
%
%   cfg = [];
%   cfg.window = 0.1; % 100 ms
%   plot(partialData,cfg);

%%
% A 2D-array of line plots, each depicting the signal at each channel in a
% specified time range:
%
%   cfg = [];
%   cfg.window = [0.1 0.2]; % 100 ms to 200 ms
%   plot(partialData,cfg);

%%
% A "movie" of the 3D-plots:
%
%   clf
%   cfg = [];
%   cfg.start = 0.1;
%   cfg.end = 0.2;
%   frameMovie(partialData,cfg);

##### SOURCE END #####
--></body></html>